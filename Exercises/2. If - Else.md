# Chapter 2. if - else

## Check if a point P is closer to point A or point B in 2D

### **Topic:** *Check if a Point is Closer to A or B in 2D*

### **Explanation:**

In a 2D plane, a **point** is defined by its coordinates, usually written as (x, y). The **distance** between two points tells us how far apart they are.

For example, if we have:

* Point A = (x‚ÇÅ, y‚ÇÅ)
* Point B = (x‚ÇÇ, y‚ÇÇ)
* Point P = (x, y)

We want to find out which point ‚Äî A or B ‚Äî is **closer** to point P.

To figure this out, we calculate the distance from P to both A and B and then compare them. You don't need to use square roots ‚Äî just compare the **squared distances** (it‚Äôs faster and gives the same result for comparison).

---

### **Exercise:**

Write a function `closer_point(p, a, b)` that takes:

* `p`: a tuple representing the coordinates of point P
* `a`: a tuple representing the coordinates of point A
* `b`: a tuple representing the coordinates of point B

The function should return:

* `'A'` if P is closer to A
* `'B'` if P is closer to B
* `'Equal'` if the distances are the same

---

### **Example:**

```python
closer_point((1, 2), (0, 0), (5, 5))     # Output: 'A'  
closer_point((4, 4), (0, 0), (8, 8))     # Output: 'Equal'  
closer_point((7, 3), (2, 3), (10, 3))    # Output: 'B'
```



## Is point on line?

### **Topic:** *Is Point P on Line in 1D?*

---

### **Simple Explanation:**

In one-dimensional space (like a number line), a line segment is just the portion between two points ‚Äî for example, between point A and point B.

We want to check whether a third point P lies *on* this segment. That means P should be:

* Greater than or equal to the smaller of A and B, **and**
* Less than or equal to the larger of A and B.

In simple terms, P is ‚Äúbetween‚Äù A and B ‚Äî or equal to one of them.

For example:

* If A = 2, B = 5, and P = 3 ‚Üí P is between 2 and 5 ‚Üí ‚úÖ
* If A = -5, B = -2, and P = -3 ‚Üí P is between -5 and -2 ‚Üí ‚úÖ
* If A = -5, B = -2, and P = -6 ‚Üí P is outside the range ‚Üí ‚ùå
* If A = 2, B = 5, and P = 2 ‚Üí P is between 2 and 5 ‚Üí ‚úÖ

It doesn‚Äôt matter whether A is smaller than B or the other way around ‚Äî we always check the range between them.

---

### **Exercise:**

Write a function `is_point_on_line_1d(a, b, p)` that returns `True` if point `p` lies on the line segment between `a` and `b`, and `False` otherwise.

---

### **Example Usage:**

```python
is_point_on_line_1d(2, 5, 3)      # Output: True  
is_point_on_line_1d(5, 2, 3)      # Output: True  
is_point_on_line_1d(2, 5, 6)      # Output: False  
is_point_on_line_1d(4, 4, 4)      # Output: True  (A single point segment)
is_point_on_line_1d(4, 4, 5)      # Output: False

# With negative numbers:
is_point_on_line_1d(-5, -2, -3)   # Output: True  
is_point_on_line_1d(-5, -2, -6)   # Output: False  
is_point_on_line_1d(-2, -5, -4)   # Output: True  
is_point_on_line_1d(-1, 3, 0)     # Output: True
```


## Are two lines overlapping or touching in 1D

### **Topic:** *Are Two Lines Overlapping or Touching in 1D*

---

### üß† **Simple Explanation:**

Imagine a number line ‚Äî just a straight line with numbers going from negative to positive. You can draw a line segment between two points, like from -3 to 2. This segment includes every number between -3 and 2.

Now, suppose you have **two such line segments**. You want to check:

* Do they **overlap** (share some part)?
* Do they **touch** (meet at exactly one point)?
* Or are they **completely separate**?

For example:

* Line A: from -3 to 1
* Line B: from 0 to 4
  They **overlap**, because they both include 0 and 1.

Or:

* Line A: from -5 to -2
* Line B: from -2 to 3
  They **touch** at -2.

---

### üìò **Exercise:**

Write a function `are_lines_touching_or_overlapping(start1, end1, start2, end2)` that returns `True` if the two 1D line segments are overlapping or touching, and `False` if they are completely separate.

üìå Make sure your function works correctly even if the start is greater than the end ‚Äî the order shouldn't matter.

---

### üîç **Example Usage:**

```python
are_lines_touching_or_overlapping(1, 4, 3, 6)        # Output: True   (Overlap from 3 to 4)
are_lines_touching_or_overlapping(1, 3, 3, 5)        # Output: True   (Touch at point 3)
are_lines_touching_or_overlapping(1, 2, 3, 4)        # Output: False  (Completely separate)

# Examples with negative numbers
are_lines_touching_or_overlapping(-3, 1, 0, 4)       # Output: True   (Overlap from 0 to 1)
are_lines_touching_or_overlapping(-5, -2, -2, 3)     # Output: True   (Touch at point -2)
are_lines_touching_or_overlapping(-10, -6, -5, -1)   # Output: False  (No touch or overlap)
are_lines_touching_or_overlapping(-2, -7, -4, -3)    # Output: True   (Overlap from -4 to -3, even with reversed inputs)
```

## Is a point inside a rectangle?

**Topic:** *Is a Point Inside a Rectangle (with Sides Parallel to the Axes)?*

---

### üß† **Explanation:**

In geometry, a **rectangle** is a shape with four sides and four right angles. When the sides of a rectangle are **parallel to the x and y axes**, it means the edges of the rectangle are either **horizontal or vertical**‚Äînot slanted.

To describe such a rectangle, we only need two opposite corners:

* The **bottom-left corner** (`x1`, `y1`)
* The **top-right corner** (`x2`, `y2`)

A **point** has two values: `x` and `y`‚Äîits horizontal and vertical positions.

To check if a point lies **inside** (or on the border of) the rectangle, we see if:

* The `x` value of the point is between `x1` and `x2`, and
* The `y` value of the point is between `y1` and `y2`.

This assumes `x1 < x2` and `y1 < y2` (which means the first point is bottom-left and the second is top-right).

---

### ‚úÖ **Exercise:**

Write a function `is_point_inside_rectangle(x1, y1, x2, y2, px, py)` that returns `True` if the point `(px, py)` lies inside or on the boundary of the rectangle defined by corners `(x1, y1)` and `(x2, y2)`, and `False` otherwise.

---

### üîç **Example Usage:**

```python
is_point_inside_rectangle(0, 0, 10, 5, 3, 2)   # Output: True
is_point_inside_rectangle(0, 0, 10, 5, 10, 5)  # Output: True  (point on the corner)
is_point_inside_rectangle(0, 0, 10, 5, 11, 5)  # Output: False (outside the rectangle)
is_point_inside_rectangle(-5, -5, 5, 5, 0, 0)  # Output: True  (inside a rectangle with negative coordinates)
```

Note: **try with negative numbers** and **boundary points** to test your understanding.


## Are rectangles (with sides parallel to axes) intersecting?

### **Topic:** *Are Rectangles Intersecting?*

---

### **Explanation:**

A **rectangle** on a 2D plane can be defined by its two opposite corners ‚Äî the bottom-left and the top-right. For example, suppose a rectangle has its bottom-left corner at (1, 2) and top-right corner at (4, 5). This rectangle stretches from x = 1 to x = 4 and from y = 2 to y = 5.

Two rectangles are said to **intersect** if they share **any area** ‚Äî even a single point on their boundary counts. If one is completely to the left, right, above, or below the other, then they **do not intersect**.

---

### **Exercise:**

Write a function `are_rectangles_intersecting(rect1, rect2)` that takes two rectangles and returns `True` if they intersect, otherwise returns `False`.

Each rectangle is represented as a tuple of two points:
`((x1, y1), (x2, y2))`, where

* `(x1, y1)` is the **bottom-left corner**
* `(x2, y2)` is the **top-right corner**

#### **Function Signature:**

```python
def are_rectangles_intersecting(rect1: tuple, rect2: tuple) -> bool:
```

---

### **Example Usage:**

```python
# Rectangles overlap partially
are_rectangles_intersecting(((0, 0), (3, 3)), ((2, 2), (5, 5)))  
# Output: True

# One rectangle is completely to the right of the other
are_rectangles_intersecting(((0, 0), (1, 1)), ((2, 2), (3, 3)))  
# Output: False

# Touching at corner
are_rectangles_intersecting(((0, 0), (2, 2)), ((2, 2), (4, 4)))  
# Output: True

# One rectangle inside another
are_rectangles_intersecting(((0, 0), (5, 5)), ((1, 1), (2, 2)))  
# Output: True
```

---

### ‚úÖ **Note to Learners:**

Try to reason geometrically:
Two rectangles **do not intersect** if:

* One is entirely to the **left** of the other
* One is entirely to the **right** of the other
* One is entirely **above** the other
* One is entirely **below** the other

If none of these cases apply, the rectangles must intersect!

## Is point on line segment in 2D - TODO:Expand

## Are two lines segments intersecting in 2D - TODO:Expand

## Device impurity formula for a set with only two classes given the counts of each class.
**Topic:** *Devise Your Own Impurity Formula*

---

### **Explanation (Simple Terms)**

When we try to split data into two groups in machine learning (especially in decision trees), we want to know how ‚Äúmixed‚Äù a set is ‚Äî meaning how many items from different classes are in the same set. This ‚Äúmixed-ness‚Äù is called *impurity*.

* If all the items are from the **same class**, the set is **pure** ‚Äî impurity is **0**.
* If the items are **equally split between two classes**, the set is **maximally impure** ‚Äî impurity is **high**.

You might have heard of common impurity measures like **Gini Index** or **Entropy**, but in this exercise, you will **create your own** formula for impurity using the counts of the two classes.

---

### **Exercise**

Write a function `my_impurity(c1, c2)` that calculates the impurity of a set containing two classes:

* `c1` is the number of examples from **class 1**
* `c2` is the number of examples from **class 2**

You should **devise your own formula** to calculate impurity. Your formula must meet these conditions:

1. If all items are from one class (`c1 = 0` or `c2 = 0`), impurity should be `0`.
2. The impurity should increase as the classes become more evenly balanced.
3. The impurity should be **maximum** when `c1 == c2`.

You may use arithmetic operators like `+`, `-`, `*`, `/`, and functions like `abs()` if needed.

---

### **Function Signature**

```python
def my_impurity(c1, c2):
    # your formula here
    return impurity_value
```

---

### **Example Usage**

Assuming you devise this impurity formula:
`impurity = (2 * min(c1, c2)) / (c1 + c2)`

Then:

```python
my_impurity(0, 5)     # Output: 0.0
my_impurity(5, 5)     # Output: 1.0
my_impurity(7, 3)     # Output: 0.6
my_impurity(9, 1)     # Output: 0.2
```

Try a few formulas. Test and compare their outputs. Pick one that makes sense to you and meets the conditions above.

---

**Bonus Challenge:**
Can you design a formula that gives values between 0 and 1 **and** changes smoothly with the ratio of the classes?

---
