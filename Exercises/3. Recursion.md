# Chapter 3. If - Else + Recursion:

## Factorial using recursion

**Topic:** *Factorial using Recursion*

---

### **Simple Explanation:**

A **factorial** of a number is the result of multiplying all whole numbers from that number down to 1.

For example:

* The factorial of 5 is: `5 Ã— 4 Ã— 3 Ã— 2 Ã— 1 = 120`
* The factorial of 3 is: `3 Ã— 2 Ã— 1 = 6`
* The factorial of 1 is: `1`

The factorial of 0 is defined as **1** (by convention).

Now, there's a smart way to compute factorials using something called **recursion**. In recursion, a function calls itself with a smaller input to eventually solve a problem.

Example logic:

* factorial(5) = 5 Ã— factorial(4)
* factorial(4) = 4 Ã— factorial(3)
* ...
* factorial(1) = 1 (this is called the *base case*)

So it keeps breaking the problem into smaller parts until it reaches 1.

---

### **Exercise:**

Write a function `factorial_recursive(n)` that takes one argument `n` (a non-negative integer) and returns the factorial of that number using recursion.

If `n` is 0, the function should return 1.

---

### **Example:**

```python
factorial_recursive(5)  # Output: 120  
factorial_recursive(3)  # Output: 6  
factorial_recursive(0)  # Output: 1  
factorial_recursive(1)  # Output: 1  
```

> ðŸ’¡ *Hint for learners:* Think about how you can express `factorial(n)` using `factorial(n-1)`. Also, make sure to stop when `n` reaches 0 or 1 â€” that's your base case.


## Multiplication using recursion

### **Topic:** *Multiplication using Recursion*

#### **Simple Explanation:**

Multiplication means adding a number to itself a certain number of times.
For example, 4 multiplied by 3 means:
`4 + 4 + 4 = 12`.

Recursion means a function that calls itself to solve smaller versions of the same problem.
Instead of using the `*` (multiplication) operator directly, you can use recursion to repeatedly add a number.

So, to multiply `a` and `b`, you can add `a` to the result of multiplying `a` and `b-1`.

Also, consider that:

* If `b` is 0, the result is 0 (anything multiplied by 0 is 0).
* If `b` is negative, handle it by converting to positive, and then negating the result.

---

### **Exercise:**

Write a function `multiply_recursive(a, b)` that multiplies two integers using recursion (without using the `*` operator).

* `a`: the first number (int)
* `b`: the second number (int)

Return the product of `a` and `b`.

---

### **Example Usage:**

```python
multiply_recursive(4, 3)     # Output: 12
multiply_recursive(5, 0)     # Output: 0
multiply_recursive(7, -2)    # Output: -14
multiply_recursive(-3, -3)   # Output: 9
```

## Compute power(x, n) using recursion where n is a positive integer.

**Topic:** *Compute Power Using Recursion*
**Explanation:** The *power* of a number means multiplying it by itself several times. For example, $x^n$ means multiplying $x$ by itself $n$ times.

* $2^3 = 2 \times 2 \times 2 = 8$
* $5^2 = 5 \times 5 = 25$

Recursion is a method where a function calls itself to solve a smaller part of the same problem.
For computing $x^n$ recursively:

* If $n = 1$, the result is $x$.
* Otherwise, $x^n = x \times x^{n-1}$.

**Exercise:**
Write a function `power(x, n)` that uses recursion to return $x^n$, where `n` is a positive integer.

**Example:**

```python
power(2, 3)   # Output: 8
power(5, 2)   # Output: 25
```

----


## Compute power(x, n) using recursion where n is an integer i.e. it can be positive, negative or zero.

**Topic:** *Compute Power using Recursion*
**Explanation:** Power means multiplying a number by itself several times. For example, $2^3 = 2 \times 2 \times 2 = 8$. Here, $2$ is called the base, and $3$ is called the exponent.

If the exponent is:

* **Zero**, any non-zero base raised to the power of 0 is 1. (e.g., $5^0 = 1$)
* **Positive**, it means multiplying the base that many times. (e.g., $3^2 = 3 \times 3 = 9$)
* **Negative**, it means dividing 1 by the base raised to the positive exponent. (e.g., $2^{-3} = 1 / (2^3) = 1/8$)

We can calculate power using **recursion**, where the function calls itself with a smaller exponent until it reaches the base case.

**Exercise:**
Write a function `compute_power(x, n)` that returns $x^n$ using recursion. Handle positive, negative, and zero values of $n$.

**Example:**

```python
compute_power(2, 3)   # Output: 8
compute_power(2, -3)  # Output: 0.125
compute_power(5, 0)   # Output: 1
```


## Division using recursion to find quotient and remainder

### **Topic:** *Division using Recursion to Find Quotient and Remainder*

#### **Simple Explanation:**

Division is the process of finding how many times one number (called the **divisor**) fits into another number (called the **dividend**).
For example, in `17 Ã· 5`, the number 5 fits into 17 **three** times (thatâ€™s the **quotient**) and there are **2** left over (thatâ€™s the **remainder**), because:

```
5 + 5 + 5 = 15, and 17 - 15 = 2  
So, 17 Ã· 5 gives quotient = 3 and remainder = 2
```

**Recursion** means solving a problem by breaking it into smaller versions of the same problem. In this case, we repeatedly subtract the divisor from the dividend and count how many times we do it until whatâ€™s left is smaller than the divisor (thatâ€™s the remainder).

---

### **Exercise:**

Write a function `recursive_divide(dividend, divisor)` that returns a tuple `(quotient, remainder)` using recursion.
You **must not** use the `//` or `%` operators.

* `dividend`: a non-negative integer
* `divisor`: a positive integer

**Return:** A tuple of two integers: `(quotient, remainder)`

---

### **Example Usage:**

```python
recursive_divide(17, 5)   # Output: (3, 2)
recursive_divide(20, 4)   # Output: (5, 0)
recursive_divide(7, 3)    # Output: (2, 1)
recursive_divide(0, 1)    # Output: (0, 0)
```

## Compute HCF using Euclid's Method with Recursion*

**Topic:** *Compute HCF/GCD using Euclid's Method with Recursion*

---

### **Explanation:**

HCF stands for **Highest Common Factor**, also known as **GCD (Greatest Common Divisor)**. It is the largest number that evenly divides two numbers.

For example:

* The HCF of 12 and 18 is 6, because 6 is the biggest number that divides both 12 and 18 without a remainder.

**Euclidâ€™s Method** is a smart and efficient way to compute the HCF. It works like this:

* If `b` is 0, the HCF is `a`.
* Otherwise, HCF of `a` and `b` is the same as the HCF of `b` and `a % b`.

This method keeps reducing the problem until it finds the HCF. We can use **recursion** to apply this method repeatedly until we get the answer.

---

### **Exercise:**

Write a function named `compute_hcf(a, b)` that takes two positive integers `a` and `b` and returns their HCF using Euclid's method with recursion.

* You should **use recursion** to solve this problem.
* The function should return an integer.

---

### **Example Usage:**

```python
compute_hcf(12, 18)     # Output: 6
compute_hcf(100, 25)    # Output: 25
compute_hcf(17, 13)     # Output: 1
compute_hcf(0, 5)       # Output: 5
```

> ðŸ’¡ *Hint: Try to express the logic using the rule: HCF(a, b) = HCF(b, a % b)*
> Remember that recursion means your function will call itself with smaller values until it reaches a stopping point.


## Tower of hanoi using recursion. 

**Topic:** *Tower of Hanoi (Recursion)*
**Explanation:** You have three pegs: **A** (source), **B** (auxiliary), and **C** (target). A stack of discs sits on **A**, smallest on top. You must move the whole stack to **C** by moving one disc at a time and never placing a larger disc on a smaller one.
Recursion idea:

* For **1 disc**: move disc 1 from **A** to **C**.
* For **2 discs**: move disc 1 from **A**â†’**B**, move disc 2 from **A**â†’**C**, move disc 1 from **B**â†’**C**.
* For **3 discs**: first solve the 2-disc problem **A**â†’**B**, then move disc 3 **A**â†’**C**, then solve the 2-disc problem **B**â†’**C**.
  General rule for **n**:

1. Move **nâˆ’1** discs from **source** to **auxiliary**, 2) move disc **n** from **source** to **target**, 3) move **nâˆ’1** discs from **auxiliary** to **target**.

**Exercise:**
Write a function `solve_hanoi(n, source='A', auxiliary='B', target='C')` that:

* Prints each move exactly in the format: `Moving <disc> from <source> to <target>.`
* Uses recursion: base case `n == 1`, recursive case for `n > 1` using the general rule above.
* Returns the **total number of moves** performed.

**Example:**

```python
# 1 disc
solve_hanoi(1)
# Output:
# Moving 1 from A to C.
# Returns: 1
```

```python
# 2 discs
solve_hanoi(2)
# Output:
# Moving 1 from A to B.
# Moving 2 from A to C.
# Moving 1 from B to C.
# Returns: 3
```

```python
# 3 discs
solve_hanoi(3)
# Output:
# Moving 1 from A to C.
# Moving 2 from A to B.
# Moving 1 from C to B.
# Moving 3 from A to C.
# Moving 1 from B to A.
# Moving 2 from B to C.
# Moving 1 from A to C.
# Returns: 7
```
