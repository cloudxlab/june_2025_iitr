# Chapter 3. If - Else + Recursion:

## Factorial using recursion

**Topic:** *Factorial using Recursion*

---

### **Simple Explanation:**

A **factorial** of a number is the result of multiplying all whole numbers from that number down to 1.

For example:

* The factorial of 5 is: `5 Ã— 4 Ã— 3 Ã— 2 Ã— 1 = 120`
* The factorial of 3 is: `3 Ã— 2 Ã— 1 = 6`
* The factorial of 1 is: `1`

The factorial of 0 is defined as **1** (by convention).

Now, there's a smart way to compute factorials using something called **recursion**. In recursion, a function calls itself with a smaller input to eventually solve a problem.

Example logic:

* factorial(5) = 5 Ã— factorial(4)
* factorial(4) = 4 Ã— factorial(3)
* ...
* factorial(1) = 1 (this is called the *base case*)

So it keeps breaking the problem into smaller parts until it reaches 1.

---

### **Exercise:**

Write a function `factorial_recursive(n)` that takes one argument `n` (a non-negative integer) and returns the factorial of that number using recursion.

If `n` is 0, the function should return 1.

---

### **Example:**

```python
factorial_recursive(5)  # Output: 120  
factorial_recursive(3)  # Output: 6  
factorial_recursive(0)  # Output: 1  
factorial_recursive(1)  # Output: 1  
```

> ðŸ’¡ *Hint for learners:* Think about how you can express `factorial(n)` using `factorial(n-1)`. Also, make sure to stop when `n` reaches 0 or 1 â€” that's your base case.


## Compute HCF using Euclid's Method with Recursion*

**Topic:** *Compute HCF using Euclid's Method with Recursion*

---

### **Explanation:**

HCF stands for **Highest Common Factor**, also known as **GCD (Greatest Common Divisor)**. It is the largest number that evenly divides two numbers.

For example:

* The HCF of 12 and 18 is 6, because 6 is the biggest number that divides both 12 and 18 without a remainder.

**Euclidâ€™s Method** is a smart and efficient way to compute the HCF. It works like this:

* If `b` is 0, the HCF is `a`.
* Otherwise, HCF of `a` and `b` is the same as the HCF of `b` and `a % b`.

This method keeps reducing the problem until it finds the HCF. We can use **recursion** to apply this method repeatedly until we get the answer.

---

### **Exercise:**

Write a function named `compute_hcf(a, b)` that takes two positive integers `a` and `b` and returns their HCF using Euclid's method with recursion.

* You should **use recursion** to solve this problem.
* The function should return an integer.

---

### **Example Usage:**

```python
compute_hcf(12, 18)     # Output: 6
compute_hcf(100, 25)    # Output: 25
compute_hcf(17, 13)     # Output: 1
compute_hcf(0, 5)       # Output: 5
```

> ðŸ’¡ *Hint: Try to express the logic using the rule: HCF(a, b) = HCF(b, a % b)*
> Remember that recursion means your function will call itself with smaller values until it reaches a stopping point.


## Multiplication using recursion

### **Topic:** *Multiplication using Recursion*

#### **Simple Explanation:**

Multiplication means adding a number to itself a certain number of times.
For example, 4 multiplied by 3 means:
`4 + 4 + 4 = 12`.

Recursion means a function that calls itself to solve smaller versions of the same problem.
Instead of using the `*` (multiplication) operator directly, you can use recursion to repeatedly add a number.

So, to multiply `a` and `b`, you can add `a` to the result of multiplying `a` and `b-1`.

Also, consider that:

* If `b` is 0, the result is 0 (anything multiplied by 0 is 0).
* If `b` is negative, handle it by converting to positive, and then negating the result.

---

### **Exercise:**

Write a function `multiply_recursive(a, b)` that multiplies two integers using recursion (without using the `*` operator).

* `a`: the first number (int)
* `b`: the second number (int)

Return the product of `a` and `b`.

---

### **Example Usage:**

```python
multiply_recursive(4, 3)     # Output: 12
multiply_recursive(5, 0)     # Output: 0
multiply_recursive(7, -2)    # Output: -14
multiply_recursive(-3, -3)   # Output: 9
```


## Division using recursion to find quotient and remainder

### **Topic:** *Division using Recursion to Find Quotient and Remainder*

#### **Simple Explanation:**

Division is the process of finding how many times one number (called the **divisor**) fits into another number (called the **dividend**).
For example, in `17 Ã· 5`, the number 5 fits into 17 **three** times (thatâ€™s the **quotient**) and there are **2** left over (thatâ€™s the **remainder**), because:

```
5 + 5 + 5 = 15, and 17 - 15 = 2  
So, 17 Ã· 5 gives quotient = 3 and remainder = 2
```

**Recursion** means solving a problem by breaking it into smaller versions of the same problem. In this case, we repeatedly subtract the divisor from the dividend and count how many times we do it until whatâ€™s left is smaller than the divisor (thatâ€™s the remainder).

---

### **Exercise:**

Write a function `recursive_divide(dividend, divisor)` that returns a tuple `(quotient, remainder)` using recursion.
You **must not** use the `//` or `%` operators.

* `dividend`: a non-negative integer
* `divisor`: a positive integer

**Return:** A tuple of two integers: `(quotient, remainder)`

---

### **Example Usage:**

```python
recursive_divide(17, 5)   # Output: (3, 2)
recursive_divide(20, 4)   # Output: (5, 0)
recursive_divide(7, 3)    # Output: (2, 1)
recursive_divide(0, 1)    # Output: (0, 0)
```
